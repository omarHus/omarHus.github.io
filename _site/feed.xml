<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Omar Husain</title>
		<description>My Portfolio</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Self-Leveling Glider - Controls Project</title>
				<description>&lt;!-- Glider image will go here --&gt;
&lt;p&gt;&lt;img src=&quot;/images/glider.jpg&quot; alt=&quot;Glider&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The motivation for this project was to design a control system for a glider that would allow it to correct it’s orientation and fly straight and level given any starting angle and any external disturbances.&lt;/p&gt;

&lt;p&gt;The system consists of a lipo battery, an inertial measuring unit (IMU), a PID controller, and three servo motors to actuate the control flaps.&lt;/p&gt;

&lt;p&gt;This project presented both software and electrical design decisions. In order to power all three servos and the micro-controller, a 12V 1.5A lipo battery was chosen. Each servo is rated at 5V; therefore, a voltage regulator was used to step down the voltage to a constant 5V across each servo. In addition, a raspberry Pi was connected to the circuit in order to feed data from the controller and store it to be able to theoretically assign gain values to our controller in Matlab. The full circuit is shown in Fig. 1.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;!-- Circuit image will go here --&gt;
&lt;p&gt;&lt;img src=&quot;/images/Glidercircuit.png&quot; alt=&quot;Circuit&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;
&lt;center&gt;Fig. 1: Circuit Layout&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;With the electronics sorted, the next step was to code the controller. An arduino nano was used with an IMU that had a nicely documented arduino library. The IMU fed raw data from an accelerometer and gyroscope, which had to be transformed into values for the roll, pitch, and yaw orientation of the glider. A complicated mathematical transformation known as a Quaternion was used to map the raw sensor output into useable orientation data. With this transformed data, the PID controller calculated the deviation from the desired orientation of straight and level. The output of the controller was a command for the servos attached to the rudder, ailerons, and elevator of the glider and the feedback system cycled through again.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;!-- Real Circuit image will go here --&gt;
&lt;p&gt;&lt;img src=&quot;/images/circuit.jpg&quot; alt=&quot;Circuit&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;
&lt;center&gt;Fig. 2: Controller Circuit Board Soldered&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Finally, the PID controller needed to be tuned, or given the proper gain values, in order for the system to be stable. At first, the goal was to theoretically determine the gain values by taking the transformed data from the controller to the Raspberry Pi and then running it through a Matlab PID tuning function. This function tries to determine the transfer function given some data and then provides gain values based on a step response of the system as shown in Fig. 3.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;!-- Matlab image will go here --&gt;
&lt;p&gt;&lt;img src=&quot;/images/matlab.png&quot; alt=&quot;Matlab&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;
&lt;center&gt;Fig. 3: Matlab PID Tuner Results&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;However, theory does not always match reality. So the gains were initially set to these values shown above, but this produced poor results. The PID gains were instead tuned experimentally, by changing each gain individually by small increments until the desired result was obtained. You can see the final results on youtube:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;&lt;iframe width=&quot;100%&quot; height=&quot;400px&quot; src=&quot;https://www.youtube.com/embed/f1AE9T4lfGI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 01 Nov 2017 00:00:00 -0400</pubDate>
				<link>http://localhost:4000/2017/11/SelfLevelingGlider</link>
				<guid isPermaLink="true">http://localhost:4000/2017/11/SelfLevelingGlider</guid>
			</item>
		
			<item>
				<title>Ignition State Machine - Uottawa Rocketry</title>
				<description>&lt;p&gt;For two semesters I joined the uOttawa Rocketry team and I was able to participate in various aspects of the rocket’s design. Our goal was to build a hybrid rocket (liquid oxidizer, solid fuel) that would achieve a target apogee of 10,000ft, as part of the Intercollegiate Rocket Engineering Competition.&lt;/p&gt;

&lt;p&gt;I designed and wrote the software for the ignition system of the rocket. The system consisted of an igniter relay, control valve, microcontroller and wireless communication via a Xbee. To control the system from a safe distance I designed a state machine which used serial input to engage specific commands in the ignition sequence. The different states of the system are shown in the table below.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;&lt;/center&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;State&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Number&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Action&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STOP&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Close the valve, turn the igniter relay off.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IGNITE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Turn the igniter relay on, starting the igniter.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OPEN&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Keep the igniter relay on, open the valve, keep it open for 10 seconds&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CLOSE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Close the valve&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WAIT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Do nothing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PING&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Send &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;I AM ALIVE!&quot;&lt;/code&gt; to the base station over the radio&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The state machine ensures that an acceptable sequence of actions occurs no matter what command is given to the controller. These relationships are typically represented in a state transition map.&lt;/p&gt;

&lt;!-- Insert picture of state map --&gt;

&lt;p&gt;The tricky part for this program was to ensure that the system could be turned off at any moment. For a non-wireless system, this is a simple task. There exists a function, called the intercept function, which when called stops all other functions and runs parallel to the current program.  An intercept function could not be called in this case, because the pins on the controller that are used to communicate this call were already being used by the Xbee to wirelessly transmit our serial commands. Therefore, making use of the state machine, the solution was to poll the serial input frequently, so that if a ‘STOP’ command occured, the system would act immediately.&lt;/p&gt;

</description>
				<pubDate>Sat, 30 Sep 2017 00:00:00 -0400</pubDate>
				<link>http://localhost:4000/2017/09/StateMachine</link>
				<guid isPermaLink="true">http://localhost:4000/2017/09/StateMachine</guid>
			</item>
		
			<item>
				<title>Drawing Robot</title>
				<description>&lt;p&gt;&lt;img src=&quot;/images/axidraw.jpeg&quot; alt=&quot;Plotter&quot; class=&quot;img-responsive center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The drawing robot was a fun project that was mostly software based for me. It consisted of a two-dimensional plotter with a microcontroller connected to stepper motors like a 3d printer. The stepper motors drove belts that connected to a cartdridge that held the pen.&lt;/p&gt;

&lt;p&gt;I was tasked with creating a program that the controller in the robot could use to make interesting images. I decided to write a program that converted digital images into the same image but represented by continuous squiggly lines, which could easily be traced out by the robot.&lt;/p&gt;

&lt;p&gt;The squiggly lines were generated by a sine function with variable amplitude and frequency. The algorithm scanned the jpg image by a certain number of pixels per increment and based on the brightness of those pixels, a corresponding amplitude and frequency was generated for the sine function. This produced quite beautiful images and allowed the robot to move the pen with a minimum amount of lifting-off the page.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!-- Rachel Carson image will go here --&gt;
&lt;img src=&quot;/images/rachelCarson.png&quot; alt=&quot;RachelCarson&quot; class=&quot;img-responsive&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;For the electronics, an arduino uno was used with a CNC shield and drivers for the stepper motors. In order to configure the stepper motors, the potentiometers on the drivers had to be adjusted so as to set the current limit on the stepper motors. This ensures that the torque caused by these motors does not exceed the rated value.&lt;/p&gt;
</description>
				<pubDate>Fri, 22 Jan 2016 00:00:00 -0500</pubDate>
				<link>http://localhost:4000/2016/01/drawingRobot</link>
				<guid isPermaLink="true">http://localhost:4000/2016/01/drawingRobot</guid>
			</item>
		
			<item>
				<title>Properly Damped CPR Dummy</title>
				<description>
</description>
				<pubDate>Thu, 21 Jan 2016 00:00:00 -0500</pubDate>
				<link>http://localhost:4000/2016/01/Biobuddy</link>
				<guid isPermaLink="true">http://localhost:4000/2016/01/Biobuddy</guid>
			</item>
		
			<item>
				<title>First Post</title>
				<description>&lt;p&gt;Quick tutorial on how to build a site like this will be posted shortly…&lt;/p&gt;
</description>
				<pubDate>Wed, 14 Mar 2012 00:00:00 -0400</pubDate>
				<link>http://localhost:4000/2012/03/First</link>
				<guid isPermaLink="true">http://localhost:4000/2012/03/First</guid>
			</item>
		
	</channel>
</rss>
